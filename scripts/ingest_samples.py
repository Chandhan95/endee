"""Script to ingest sample documents"""

import asyncio
import logging
from pathlib import Path

from src.rag_service import RAGService

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


SAMPLE_DOCUMENTS = {
    "python_guide": {
        "name": "Python Programming Guide",
        "content": """
        Python is a high-level, interpreted programming language known for its simplicity and readability.
        
        Variables and Data Types:
        Python uses dynamic typing, so you don't need to declare variable types. Common data types include:
        - str: strings like "hello"
        - int: integers like 42
        - float: floating point numbers like 3.14
        - list: ordered collections like [1, 2, 3]
        - dict: key-value pairs like {"name": "John", "age": 30}
        - tuple: immutable sequences like (1, 2, 3)
        - set: unordered unique elements like {1, 2, 3}
        
        Functions:
        Functions are reusable blocks of code defined with the 'def' keyword.
        They can accept parameters and return values.
        
        Example:
        def greet(name):
            return f"Hello, {name}!"
        
        Classes and Objects:
        Python supports object-oriented programming through classes.
        Classes define blueprints for creating objects.
        
        Example:
        class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age
        
        Control Flow:
        - if/elif/else: conditional statements
        - for: iterate over sequences
        - while: loop while condition is true
        - break: exit loop
        - continue: skip to next iteration
        
        Popular Libraries:
        - NumPy: numerical computing
        - Pandas: data manipulation
        - Django/Flask: web frameworks
        - TensorFlow/PyTorch: machine learning
        - Requests: HTTP library
        """
    },
    "vector_databases": {
        "name": "Vector Databases Overview",
        "content": """
        Vector databases are specialized databases designed to efficiently store and search high-dimensional vectors.
        
        What are Vectors?
        Vectors are numerical representations of data, typically generated by embedding models.
        Each vector is a list of numbers, and similarity between vectors indicates semantic similarity.
        
        Key Characteristics:
        - Store embeddings/vectors efficiently
        - Support fast similarity search (nearest neighbor)
        - Handle high-dimensional data
        - Scale to millions or billions of vectors
        
        Distance Metrics:
        Different metrics measure similarity between vectors:
        - Euclidean (L2): straight-line distance
        - Manhattan (L1): sum of absolute differences
        - Cosine: angle between vectors
        - Dot Product: projection of one vector onto another
        
        Use Cases:
        - Semantic search: find semantically similar content
        - Recommendation systems: find similar products or users
        - Image search: find visually similar images
        - Question answering: find relevant documents
        - Anomaly detection: find unusual patterns
        
        Endee is a high-performance vector database optimized for speed and efficiency.
        It supports SIMD optimizations for faster search operations.
        """
    },
    "rag_systems": {
        "name": "RAG (Retrieval-Augmented Generation)",
        "content": """
        Retrieval-Augmented Generation (RAG) is a technique combining information retrieval with text generation.
        
        How RAG Works:
        1. Document Ingestion: Load and process documents
        2. Embedding: Convert documents to vector embeddings
        3. Storage: Store vectors in a vector database
        4. Query: Convert user query to embedding
        5. Retrieval: Find similar documents using vector search
        6. Generation: Use retrieved documents as context for LLM
        
        Benefits:
        - Provides up-to-date information without retraining
        - Reduces hallucinations in language models
        - Enables customizable knowledge bases
        - More cost-effective than fine-tuning
        - Improves answer accuracy and relevance
        
        Architecture Components:
        - Embedding Model: Converts text to vectors
        - Vector Database: Stores and searches embeddings
        - Retrieval Engine: Finds relevant documents
        - Language Model: Generates answers from context
        
        Challenges:
        - Chunking strategy affects retrieval quality
        - Embedding quality impacts search accuracy
        - Context window limitations
        - Computational cost of embeddings
        
        Best Practices:
        - Use domain-specific embedding models
        - Implement proper document preprocessing
        - Optimize chunk size and overlap
        - Cache embeddings for efficiency
        - Monitor retrieval quality
        """
    }
}


async def main():
    """Ingest sample documents"""
    logger.info("Initializing RAG service...")
    rag_service = RAGService()
    
    try:
        await rag_service.initialize()
        logger.info("RAG service initialized")
        
        logger.info(f"Ingesting {len(SAMPLE_DOCUMENTS)} documents...")
        
        for doc_key, doc_info in SAMPLE_DOCUMENTS.items():
            try:
                result = await rag_service.ingest_document(
                    document_name=doc_info["name"],
                    content=doc_info["content"]
                )
                logger.info(
                    f"✓ Ingested '{result['document_name']}' "
                    f"({result['chunks_added']} chunks)"
                )
            except Exception as e:
                logger.error(f"✗ Error ingesting '{doc_info['name']}': {str(e)}")
        
        # Get statistics
        logger.info("\nSystem Statistics:")
        stats = await rag_service.get_statistics()
        logger.info(f"Statistics: {stats}")
        
        logger.info("\nSample ingestion completed successfully!")
        
    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)


if __name__ == "__main__":
    asyncio.run(main())
